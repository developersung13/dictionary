# Dictionary (Web)

1. **크로스 브라우징**(Cross Browsing)
> 최대한 많은 웹 브라우저에서 정상적으로 작동하는 웹 페이지를 개발하는 방법론 중 하나이다.
<br />

2. **폴리필**(Polyfill)
> 브라우저가 지원하지 않는 코드를 브라우저에서 사용할 수 있도록 변환한 코드 조각이나 플러그인을 말한다.
>
> e.g., `core.js`, `polyfill.io`
<br />

3. **트랜스파일**(Transfile)
> 최신 버전의 코드를 예전 버전의 코드로 변환하는 과정을 말한다.
> 
> e.g., `Babel`
<br />

4. **AJAX**(Asynchronous Javascript And XML)
> - JavaScript와 XML을 이용한 비동기적 정보 교환 기법
> - 웹 페이지의 전체가 리로드 되지 않고, 페이지의 일부분만을 서버에서 가져와 웹 페이지 화면을 동적으로 변경하는 방식
<br />

5. **CBD**(Component Based Development)
> 재사용할 수 있는 컴포넌트를 개발 또는 조합해서 하나의 애플리케이션을 만드는 개발 방법론이다.
<br />

6. **웹 사이트**(Website)
> 사용자와 상호 작용 없이 단방향으로 정보를 제공하며, HTML에 링크가 연결된 웹 페이지의 모음으로 콘텐츠가 동적으로 업데이트 되지 않는 웹이다.
<br />

7. **웹 애플리케이션**(Web Application)
> 사용자와 상호 작용하는 양방향 소통이 이뤄지는 웹이다.
<br />

8. **NaN**(Not A Number)
> 연산 과정에서 잘못된 입력을 받았음을 나타내는 기호이다.
<br />

9. **JsDoc**
> 모듈, 네임스페이스, 클래스, 메소드, 매개변수 등에 대한 API 문서 생성 도구이다.
<br />

10. **propTypes**
> 리액트에서 컴포넌트 props의 타입을 검사하기 위해 사용하는 속성이다.
<br />

11. **슈퍼셋**(Superset)
> 기존 언어에 새로운 기능과 문법을 추가해서 보완하거나 향상하는 것을 말한다. 슈퍼셋 언어는 기존 언어와 호환되며, 일반적으로 컴파일러 등으로 기존 언어 코드로 변환되어 실행된다.
>
> 슈퍼셋 언어 e.g., `TypeScript`
<br />

12. ECMAScript 표준을 따르는 **JavaScript의 7가지 데이터 타입**
> ## Primitive Types
> 1. undefined
> 2. null
> 3. Boolean
> 4. String
> 5. Symbol
> 6. Numeric(Number와 BigInt)
> ## Object Type
> 7. Object
<br />

13. **암묵적 타입 변환**(Implicit coercion conversion)
> 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것을 말한다.
<br />

14. **타입 시스템**(Type System)
> 타입 검사기가 프로그램에 타입을 할당하는데 사용하는 규칙 집합
<br />

15. **타입 애너테이션**(Type Annotation)
> 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에게 직접 알려주는 문법이다.
<br />

16. **덕 타이핑**(Duck Typing)
> 동적 타이핑의 한 종류로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다.
<br />

17. **트리쉐이킹**(Tree shaking)
> 사용하지 않는 코드를 제거하는 방식이다.
<br />

18. **IIFE**(Immediately Invoked Function Expression, 즉시 실행 함수)
```javascript
// e.g.
(function(name) {
    console.log('Hello, ' + name + '!')
})("World");
```
<br />

19. **번들링**(Bundling)
> HTML, CSS, JavaScript를 각각의 모듈로 보고 이를 조합해 하나의 묶음으로 만드는 것이다. 즉, 번들링은 묶음의 개념이며 파일을 묶는 작업 그 자체를 의미한다. 더 정확히 말하자면, 모듈 간의 의존성을 파악해 이를 바탕으로 그룹화를 하는 작업이다.
<br />

20. **번들러**(Bundler)
> 웹 애플리케이션을 개발하기 위해 필요한 HTML, CSS, JavaScript 등의 파편화된(모듈화된) 자원들을 모아서, 하나 혹은 최적의 소수 파일로 결합(번들링)하는 도구이다.
<br />

21. **렉시컬 스코프**(Lexcical Scope)
> 코드가 작성된 위치에 따라 스코프가 정해지는 것을 의미합니다. 즉, 함수가 어디서 정의되었으냐에 따라 해당 함수의 유효 범위가 결정됩니다. 정적 스코프라고도 불리며, 이는 변수의 스코프가 코드 작성 시 결정된다는 의미입니다.
<br />

22. **상위 스코프**
> 함수가 정의된 위치에서부터 가장 가까운 외부 스코프를 말합니다.

23. **클로저**(Closure)
> 클로저는 함수와 함수가 선언된 어휘적 환경(lexical environment)의 조합을 의미합니다. 이를 통해 함수가 생성될 때의 스코프와 변수를 기억하여, 생성된 이후에도 그 스코프에 접근할 수 있게 하는 것을 의미합니다.
>
> Closure의 사전적 의미는 폐쇄입니다. 클로저의 핵심은 스코프를 이용하여 변수의 접근 범위를 **폐쇄**하는 것에 있으며, 내부 함수가 자신이 선언된 어휘적 환경을 **기억**한다는 것입니다. 이는 내부 함수가 외부 함수의 스코프에 있는 변수에 접근할 수 있게 합니다.
>
> ## 구성요소
> 1. **함수** : 내부 함수로, 자신이 선언된 환경 내의 변수에 접근할 수 있습니다.
> 2. **어휘적 환경** : 함수가 선언된 위치의 스코프입니다. 이 환경은 함수가 생성될 때의 변수와 그 값들을 포함합니다.
>
> ## 장점
> 1. **전역변수 사용의 최소화**
> - 전역변수가 많으면 의도치 않게 어디에서든 접근하는 상황이 발생할 수 있는데, 클로저를 이용하면 전역변수를 최소한으로 사용함으로써 이러한 실수나 예외적인 상황을 방지할 수 있습니다.
> 2. **데이터 보존 가능**
> - 클로저 함수는 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있습니다. 따라서 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용할 수 있게 하는 폐쇄성을 갖습니다.
> 3. **모듈화를 통한 코드 재사용의 편리**
> - 클로저 함수를 각각의 변수에 할당하면, 각자 독립적으로 값을 사용하고 보존할 수 있습니다. 이와 같이 힘수의 재사용성을 극대화하고 함수 하나를 독립적인 부품의 형태로 분리하는 것을 모듈화라고 합니다. 클로저를 통해 데이터와 메소드를 묶어다닐 수 있기에 클로저는 모듈화에 유리합니다.
> 4. **정보 접근의 제한(캡슐화, Encapsulation)**
> - 클로저 모듈 패턴을 사용해 객체에 담아 여러 개의 함수를 리턴하도록 만들어 정보의 접근을 제한할 수 있는데, 이률 캡슐화라고 합니다.
> ## Closure 예시 코드 #1
> ```javascript
> function outerFunction() {
>   let outerVariable = 'I am outside!';
>
>   function innerFunction() {
>     console.log(outerVariable); // 외부 함수의 변수를 참조
>   }
>
>   return innerFunction;
> }
>
> const myClosure = outerFunction();
> myClosure(); // "I am outside!" 출력
> ```
> ## Closure 예시 코드 #2
> ```javascript
> function outer() {
>   let message = 'Hello! ';
>
>   return function inner(name) { // inner함수는 클로저
>	  return message = message + name;
>	}
> }
>
> let greeting = outer(); // 외부함수 호출. 변수 greeting은 inner 함수를 참조
> console.log(greeting('Janet')); // "Hello! Janet" 출력
> ```
> - `outer 함수`는 종료됐지만, `outer 함수` 함수 내부 변수인 `message`는 `inner 함수`를 통해 접근 가능하다. 여기서의 `inner 함수`가 바로 클로저이다.
> - 이는 클로저의 특성으로 `inner 함수`가 선언될 때 그 주변의 어휘적 환경 즉, `outer 함수`의 어휘적 환경과 함께 묶였기 때문에 클로저에서 `message`라는 변수를 참조할 수 있게 된다.
<br />

24. **`forEach 함수`와 `map 함수`의 차이점**
> ## `forEach`
> - 배열의 요소를 반복합니다.
> - 각 요소에 대해 콜백을 실행합니다.
> - 값을 반환하지 않습니다.
> ```javascript
> const a = [1, 2, 3];
> const doubled = a.forEach((num, index) => {
>   ...   
> });
>
> // doubled = undefined
> ```
> ## `map`
> - 배열의 요소를 반복합니다.
> - 각 요소에서 함수를 호출하여 결과로 새 배열을 작성하여 각 요소를 새 요소에 매핑합니다.
> ```javascript
> const a = [1, 2, 3];
> const doubled = a.map((num, index) => {
>   return num * 2;
> });
>
> // doubled = [2, 4, 6]
> ```
> - `forEach 함수`와 `map 함수`의 가장 큰 차이점은 `map 함수`는 새로운 배열을 반환한다는 것입니다. 결과가 필요하며, 원본 배열은 변경하고 싶지 않다면 `map 함수`를 선택해야 하고, 단순히 배열을 반복하고자 한다면 `forEach 함수`가 좋은 선택입니다.